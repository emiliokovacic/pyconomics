{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "043596ba-6d5d-44b3-b637-c166b810deb4",
   "metadata": {},
   "source": [
    "**Código para la descarga de Índices de Consumo del CIS**\n",
    "\n",
    "Este código usa un archivo Excel descargado de esta url https://www.cis.es/catalogo-estudios/resultados-definidos/icc para recorrer uno a uno todos los informes de la serie temporal y descargar su información en formato CSV (o en formato SAV, para luego transformarlos en CSV)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7887209d-d435-4e20-bb94-97f9e406e06a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import time\n",
    "import zipfile\n",
    "import pandas as pd\n",
    "import traceback\n",
    "import pyreadstat\n",
    "from selenium import webdriver\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.chrome.service import Service\n",
    "from selenium.webdriver.chrome.options import Options\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from webdriver_manager.chrome import ChromeDriverManager\n",
    "from selenium.webdriver.common.action_chains import ActionChains\n",
    "\n",
    "def convert_sav_to_csv(sav_file_path, csv_file_path):\n",
    "    try:\n",
    "        # Leer el archivo SAV utilizando pyreadstat\n",
    "        df, meta = pyreadstat.read_sav(sav_file_path)\n",
    "        # Guardar en formato CSV\n",
    "        df.to_csv(csv_file_path, index=False, encoding='utf-8')\n",
    "        print(f\"Archivo SAV convertido con éxito: {csv_file_path}\")\n",
    "    except Exception as e:\n",
    "        print(f\"Error al convertir el archivo SAV: {e}\")\n",
    "\n",
    "# CONFIGURACIÓN\n",
    "EXCEL_PATH = r\"C:\\Users\\emilo\\Downloads\\ICC - CIS (1).xlsx\"  # Ruta del Excel guía\n",
    "DOWNLOAD_DIR = r\"C:\\Users\\emilo\\Downloads\\descargas_cis\"         # Carpeta para los ZIP descargados\n",
    "EXTRACTED_DIR = r\"C:\\Users\\emilo\\Downloads\\csv_extraidos\"          # Carpeta para los CSV extraídos\n",
    "EMAIL = \"emilio.cobos@bde.es\"                                     # Tu email\n",
    "\n",
    "# Crear carpetas si no existen\n",
    "os.makedirs(DOWNLOAD_DIR, exist_ok=True)\n",
    "os.makedirs(EXTRACTED_DIR, exist_ok=True)\n",
    "\n",
    "# CONFIGURAR CHROME PARA DESCARGAS AUTOMÁTICAS\n",
    "options = Options()\n",
    "# Sin headless para ver la interacción (comenta la siguiente línea si quieres verlo)\n",
    "# options.add_argument(\"--headless\")\n",
    "options.add_argument(\"--no-sandbox\")\n",
    "options.add_argument(\"--disable-dev-shm-usage\")\n",
    "prefs = {\n",
    "    \"download.default_directory\": DOWNLOAD_DIR,\n",
    "    \"download.prompt_for_download\": False,\n",
    "    \"download.directory_upgrade\": True,\n",
    "    \"safebrowsing.enabled\": True\n",
    "}\n",
    "options.add_experimental_option(\"prefs\", prefs)\n",
    "\n",
    "# Iniciar WebDriver\n",
    "service = Service(ChromeDriverManager().install())\n",
    "driver = webdriver.Chrome(service=service, options=options)\n",
    "\n",
    "# LEER EXCEL\n",
    "df = pd.read_excel(EXCEL_PATH)\n",
    "df.columns = df.columns.str.strip().str.upper()\n",
    "\n",
    "if \"FECHA\" not in df.columns or \"CÓDIGO ESTUDIO\" not in df.columns:\n",
    "    raise ValueError(\"El Excel no tiene las columnas esperadas ('FECHA', 'CÓDIGO ESTUDIO')\")\n",
    "\n",
    "# Convertir la columna FECHA a formato YYYYMM\n",
    "df[\"FECHA\"] = pd.to_datetime(df[\"FECHA\"], format=\"%d-%m-%Y\", errors=\"coerce\").dt.strftime(\"%Y%m\")\n",
    "\n",
    "# PROCESAR CADA REGISTRO\n",
    "for index, row in df.iterrows():\n",
    "    codigo = row[\"CÓDIGO ESTUDIO\"]\n",
    "    fecha = row[\"FECHA\"]\n",
    "    zip_filename = f\"MD{codigo}.zip\"\n",
    "    zip_path = os.path.join(DOWNLOAD_DIR, zip_filename)\n",
    "\n",
    "    # Construir la URL de descarga\n",
    "    url_descarga = f\"https://www.cis.es/descarga-fichero-datos?anio={fecha[:4]}&codEstudio={codigo}&fichero=MD{codigo}.zip\"\n",
    "    print(f\"\\nProcesando código {codigo}, fecha {fecha}\")\n",
    "    driver.get(url_descarga)\n",
    "    time.sleep(2)  # Espera a que cargue la página\n",
    "\n",
    "    try:\n",
    "        # Rellenar el campo Email\n",
    "        email_input = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.CSS_SELECTOR, \"input[placeholder='email']\"))\n",
    "        )\n",
    "        email_input.clear()\n",
    "        email_input.send_keys(EMAIL)\n",
    "        print(\"Campo email completado.\")\n",
    "\n",
    "        # Rellenar el campo Confirmar email (usando XPath para buscar 'confirmationField' en el id)\n",
    "        confirm_email_input = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.XPATH, \"//input[contains(@id, 'confirmationField')]\"))\n",
    "        )\n",
    "        confirm_email_input.clear()\n",
    "        confirm_email_input.send_keys(EMAIL)\n",
    "        print(\"Campo confirmar email completado.\")\n",
    "\n",
    "        # Localizar y clicar el checkbox (a través del span asociado, usando un XPath insensible a mayúsculas)\n",
    "        checkbox_label = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.XPATH, \"//span[contains(@class, 'custom-control-label-text') and contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'conoce y acepta los terminos')]\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", checkbox_label)\n",
    "        time.sleep(1)\n",
    "        driver.execute_script(\"arguments[0].click();\", checkbox_label)\n",
    "        print(\"Checkbox clicado.\")\n",
    "\n",
    "        # Localizar el botón de Enviar\n",
    "        submit_button = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.ID, \"ddm-form-submit\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", submit_button)\n",
    "        time.sleep(1)\n",
    "        submit_button.click()\n",
    "        print(\"Botón Enviar clicado.\")\n",
    "\n",
    "        # Esperar 5 segundos para que se produzca la redirección a la página de descarga\n",
    "        time.sleep(5)\n",
    "\n",
    "        # Esperar a que aparezca el título de la página de descarga\n",
    "        descarga_header = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.ID, \"tituloArchivo\"))\n",
    "        )\n",
    "        print(\"Página de descarga cargada.\")\n",
    "\n",
    "        # Localizar el botón \"Descargar\"\n",
    "        descargar_button = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.XPATH, \"//a[contains(@class, 'btn btn-sm btn-primary') and contains(.,'Descargar')]\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", descargar_button)\n",
    "        time.sleep(1)\n",
    "        descargar_button.click()\n",
    "        print(\"Botón Descargar clicado.\")\n",
    "\n",
    "        # Esperar 5 segundos para dar tiempo a que se inicie la descarga\n",
    "        time.sleep(5)\n",
    "\n",
    "        # Esperar a que el ZIP se descargue correctamente (verificando que no existan archivos temporales)\n",
    "        download_wait = 0\n",
    "        max_wait = 60  # segundos máximos de espera\n",
    "        while download_wait < max_wait:\n",
    "            if os.path.exists(zip_path) and not any(fname.endswith(\".crdownload\") for fname in os.listdir(DOWNLOAD_DIR)):\n",
    "                break\n",
    "            time.sleep(2)\n",
    "            download_wait += 2\n",
    "\n",
    "        if not os.path.exists(zip_path):\n",
    "            raise Exception(f\"El archivo {zip_filename} no se descargó en el tiempo esperado.\")\n",
    "        print(\"Archivo ZIP descargado.\")\n",
    "\n",
    "        # Extraer el archivo CSV (nativo) o, si no se encuentra, buscar un archivo SAV y convertirlo a CSV\n",
    "        extracted = False\n",
    "        with zipfile.ZipFile(zip_path, \"r\") as z:\n",
    "            # Buscar primero un archivo que termine en _num.csv\n",
    "            for file in z.namelist():\n",
    "                if file.endswith(\"_num.csv\"):\n",
    "                    extracted_path = os.path.join(EXTRACTED_DIR, f\"{fecha}_num.csv\")\n",
    "                    with open(extracted_path, \"wb\") as f:\n",
    "                        f.write(z.read(file))\n",
    "                    print(f\"Extraído CSV nativo: {extracted_path}\")\n",
    "                    extracted = True\n",
    "                    break\n",
    "            # Si no se encontró, buscar un archivo que termine en .sav y convertirlo\n",
    "            if not extracted:\n",
    "                for file in z.namelist():\n",
    "                    if file.endswith(\".sav\"):\n",
    "                        sav_temp_path = os.path.join(DOWNLOAD_DIR, file)\n",
    "                        with open(sav_temp_path, \"wb\") as f:\n",
    "                            f.write(z.read(file))\n",
    "                        extracted_path = os.path.join(EXTRACTED_DIR, f\"{fecha}_num.csv\")\n",
    "                        convert_sav_to_csv(sav_temp_path, extracted_path)\n",
    "                        extracted = True\n",
    "                        # Eliminar el archivo SAV temporal\n",
    "                        os.remove(sav_temp_path)\n",
    "                        break\n",
    "            if not extracted:\n",
    "                raise Exception(\"No se encontró el archivo CSV o SAV dentro del ZIP.\")\n",
    "\n",
    "        print(f\"Archivo procesado y convertido para código {codigo} (fecha {fecha}).\")\n",
    "\n",
    "        # Eliminar el ZIP tras extraer (y convertir) el archivo\n",
    "        os.remove(zip_path)\n",
    "        print(f\"Archivo ZIP {zip_filename} eliminado.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error en formulario para código {codigo}: {e}\")\n",
    "        print(traceback.format_exc())\n",
    "        if os.path.exists(zip_path):\n",
    "            os.remove(zip_path)\n",
    "        continue  # No pasa al siguiente registro hasta que se complete exitosamente\n",
    "\n",
    "driver.quit()\n",
    "print(\"Proceso completado.\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a089b94-4da6-4660-8e05-7f6a48262a42",
   "metadata": {},
   "source": [
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37cc3bdc-d93c-4487-827d-e91662b872be",
   "metadata": {},
   "source": [
    "Este código recorre la misma serie extrayendo los archivos en formato DA y convirtiéndolos a formato RAW"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9568214-8dbc-4c3a-a07d-2e25b883ea12",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import time\n",
    "import zipfile\n",
    "import pandas as pd\n",
    "import traceback\n",
    "from selenium import webdriver\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.chrome.service import Service\n",
    "from selenium.webdriver.chrome.options import Options\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from webdriver_manager.chrome import ChromeDriverManager\n",
    "from selenium.webdriver.common.action_chains import ActionChains\n",
    "\n",
    "# CONFIGURACIÓN\n",
    "EXCEL_PATH = r\"C:\\Users\\emilo\\Downloads\\ICC - CIS (1).xlsx\"  # Ruta del Excel guía\n",
    "DOWNLOAD_DIR = r\"C:\\Users\\emilo\\Downloads\\descargas_cis\"         # Carpeta para los ZIP descargados\n",
    "EXTRACTED_DIR = r\"C:\\Users\\emilo\\Downloads\\csv_extraidos\"          # Carpeta para los archivos RAW (se usan la misma carpeta que antes)\n",
    "EMAIL = \"emilio.cobos@bde.es\"                                     # Tu email\n",
    "\n",
    "# Crear carpetas si no existen\n",
    "os.makedirs(DOWNLOAD_DIR, exist_ok=True)\n",
    "os.makedirs(EXTRACTED_DIR, exist_ok=True)\n",
    "\n",
    "# CONFIGURAR CHROME PARA DESCARGAS AUTOMÁTICAS\n",
    "options = Options()\n",
    "# Sin headless para ver la interacción\n",
    "# options.add_argument(\"--headless\")\n",
    "options.add_argument(\"--no-sandbox\")\n",
    "options.add_argument(\"--disable-dev-shm-usage\")\n",
    "prefs = {\n",
    "    \"download.default_directory\": DOWNLOAD_DIR,\n",
    "    \"download.prompt_for_download\": False,\n",
    "    \"download.directory_upgrade\": True,\n",
    "    \"safebrowsing.enabled\": True\n",
    "}\n",
    "options.add_experimental_option(\"prefs\", prefs)\n",
    "\n",
    "# Iniciar WebDriver\n",
    "service = Service(ChromeDriverManager().install())\n",
    "driver = webdriver.Chrome(service=service, options=options)\n",
    "\n",
    "# LEER EXCEL\n",
    "df = pd.read_excel(EXCEL_PATH)\n",
    "df.columns = df.columns.str.strip().str.upper()\n",
    "\n",
    "if \"FECHA\" not in df.columns or \"CÓDIGO ESTUDIO\" not in df.columns:\n",
    "    raise ValueError(\"El Excel no tiene las columnas esperadas ('FECHA', 'CÓDIGO ESTUDIO')\")\n",
    "\n",
    "# Convertir la columna FECHA a formato YYYYMM\n",
    "df[\"FECHA\"] = pd.to_datetime(df[\"FECHA\"], format=\"%d-%m-%Y\", errors=\"coerce\").dt.strftime(\"%Y%m\")\n",
    "\n",
    "# PROCESAR CADA REGISTRO\n",
    "for index, row in df.iterrows():\n",
    "    codigo = row[\"CÓDIGO ESTUDIO\"]\n",
    "    fecha = row[\"FECHA\"]\n",
    "    zip_filename = f\"MD{codigo}.zip\"\n",
    "    zip_path = os.path.join(DOWNLOAD_DIR, zip_filename)\n",
    "\n",
    "    # Construir la URL de descarga\n",
    "    url_descarga = f\"https://www.cis.es/descarga-fichero-datos?anio={fecha[:4]}&codEstudio={codigo}&fichero=MD{codigo}.zip\"\n",
    "    print(f\"\\nProcesando código {codigo}, fecha {fecha}\")\n",
    "    driver.get(url_descarga)\n",
    "    time.sleep(2)  # Espera a que cargue la página\n",
    "\n",
    "    try:\n",
    "        # Rellenar el campo Email\n",
    "        email_input = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.CSS_SELECTOR, \"input[placeholder='email']\"))\n",
    "        )\n",
    "        email_input.clear()\n",
    "        email_input.send_keys(EMAIL)\n",
    "        print(\"Campo email completado.\")\n",
    "\n",
    "        # Rellenar el campo Confirmar email (usando XPath para buscar 'confirmationField' en el id)\n",
    "        confirm_email_input = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.XPATH, \"//input[contains(@id, 'confirmationField')]\"))\n",
    "        )\n",
    "        confirm_email_input.clear()\n",
    "        confirm_email_input.send_keys(EMAIL)\n",
    "        print(\"Campo confirmar email completado.\")\n",
    "\n",
    "        # Localizar y clicar el checkbox (usando el span asociado, insensible a mayúsculas)\n",
    "        checkbox_label = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.XPATH, \"//span[contains(@class, 'custom-control-label-text') and contains(translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz'),'conoce y acepta los terminos')]\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", checkbox_label)\n",
    "        time.sleep(1)\n",
    "        driver.execute_script(\"arguments[0].click();\", checkbox_label)\n",
    "        print(\"Checkbox clicado.\")\n",
    "\n",
    "        # Localizar el botón de Enviar\n",
    "        submit_button = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.ID, \"ddm-form-submit\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", submit_button)\n",
    "        time.sleep(1)\n",
    "        submit_button.click()\n",
    "        print(\"Botón Enviar clicado.\")\n",
    "\n",
    "        # Esperar 5 segundos para que se produzca la redirección a la página de descarga\n",
    "        time.sleep(5)\n",
    "\n",
    "        # Esperar a que aparezca el título de la página de descarga\n",
    "        descarga_header = WebDriverWait(driver, 15).until(\n",
    "            EC.presence_of_element_located((By.ID, \"tituloArchivo\"))\n",
    "        )\n",
    "        print(\"Página de descarga cargada.\")\n",
    "\n",
    "        # Localizar el botón \"Descargar\"\n",
    "        descargar_button = WebDriverWait(driver, 15).until(\n",
    "            EC.element_to_be_clickable((By.XPATH, \"//a[contains(@class, 'btn btn-sm btn-primary') and contains(.,'Descargar')]\"))\n",
    "        )\n",
    "        driver.execute_script(\"arguments[0].scrollIntoView({block: 'center'});\", descargar_button)\n",
    "        time.sleep(1)\n",
    "        descargar_button.click()\n",
    "        print(\"Botón Descargar clicado.\")\n",
    "\n",
    "        # Esperar 5 segundos para dar tiempo a que se inicie la descarga\n",
    "        time.sleep(5)\n",
    "\n",
    "        # Esperar a que el ZIP se descargue correctamente (verificando que no existan archivos temporales)\n",
    "        download_wait = 0\n",
    "        max_wait = 60  # segundos máximos de espera\n",
    "        while download_wait < max_wait:\n",
    "            if os.path.exists(zip_path) and not any(fname.endswith(\".crdownload\") for fname in os.listdir(DOWNLOAD_DIR)):\n",
    "                break\n",
    "            time.sleep(2)\n",
    "            download_wait += 2\n",
    "\n",
    "        if not os.path.exists(zip_path):\n",
    "            raise Exception(f\"El archivo {zip_filename} no se descargó en el tiempo esperado.\")\n",
    "        print(\"Archivo ZIP descargado.\")\n",
    "\n",
    "        # EXTRAER: Buscar archivos cuyo nombre empieza por \"DA\"\n",
    "        extracted = False\n",
    "        with zipfile.ZipFile(zip_path, \"r\") as z:\n",
    "            for file in z.namelist():\n",
    "                # Extraer el nombre del archivo sin ruta\n",
    "                base_file = os.path.basename(file)\n",
    "                if base_file.startswith(\"DA\"):\n",
    "                    # Se guarda en la carpeta de salida con el nombre basado en la fecha y la etiqueta RAW\n",
    "                    extracted_path = os.path.join(EXTRACTED_DIR, f\"{fecha}_raw.raw\")\n",
    "                    with open(extracted_path, \"wb\") as f:\n",
    "                        f.write(z.read(file))\n",
    "                    print(f\"Extraído RAW: {extracted_path}\")\n",
    "                    extracted = True\n",
    "                    break\n",
    "            if not extracted:\n",
    "                raise Exception(\"No se encontró ningún archivo que empiece por 'DA' dentro del ZIP.\")\n",
    "\n",
    "        print(f\"Archivo procesado para código {codigo} (fecha {fecha}).\")\n",
    "\n",
    "        # Eliminar el ZIP tras extraer el archivo RAW\n",
    "        os.remove(zip_path)\n",
    "        print(f\"Archivo ZIP {zip_filename} eliminado.\")\n",
    "\n",
    "    except Exception as e:\n",
    "        print(f\"Error en formulario para código {codigo}: {e}\")\n",
    "        print(traceback.format_exc())\n",
    "        if os.path.exists(zip_path):\n",
    "            os.remove(zip_path)\n",
    "        continue  # No pasa al siguiente registro hasta que se complete exitosamente\n",
    "\n",
    "driver.quit()\n",
    "print(\"Proceso completado.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c72dd8f-5a85-4153-bb48-333e2dcb328a",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
